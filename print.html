<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ofen Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ofen Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cybozu-go/ofen" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ofen-documentation"><a class="header" href="#ofen-documentation">Ofen documentation</a></h1>
<p>Ofen is a Kubernetes controller that prefetch(preheat) container images.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-note"><a class="header" href="#design-note">Design Note</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>We are developing a custom Kubernetes operator to pre-download images for the following reasons:</p>
<p>Firstly, in our environment, we need to avoid downloading the same image multiple times when multiple Pods are created within the cluster, as this can lead to network throttling.
Secondly, to prepare for potential container registry failures, it is necessary to download images into the cluster before creating or updating workloads.
Lastly, none of the existing operators could meet our requirements.</p>
<h3 id="goal"><a class="header" href="#goal">Goal</a></h3>
<ul>
<li>Provide the capability to pre-download images required for workloads.</li>
<li>Ensure that images are present on the necessary nodes within the cluster.</li>
<li>Avoid downloading the same image multiple times within the cluster.</li>
</ul>
<h3 id="non-goal"><a class="header" href="#non-goal">Non-goal</a></h3>
<ul>
<li>Automatically listing images required for workloads.</li>
<li>Supporting various container runtimes (initial implementation supports only containerd).</li>
<li>Limiting network traffic during image downloads.</li>
<li>Deleting downloaded container images.</li>
<li>Verifying the proper functioning of downloaded container images.</li>
</ul>
<h2 id="user-stories"><a class="header" href="#user-stories">User Stories</a></h2>
<p>This section describes user stories.</p>
<ul>
<li>Assume that the Kubernetes cluster in the user stories is operated in an on-premises environment.
<ul>
<li>The team managing the Kubernetes cluster is referred to as the cluster administrators.</li>
<li>The team using the Kubernetes cluster is referred to as the tenant team.</li>
<li>Container images are downloaded from a upstream registry over the internet.</li>
<li>There is sufficient bandwidth from the cluster to the internet, but network throttling may occur if the network load becomes too high.</li>
</ul>
</li>
</ul>
<h3 id="user-story-1"><a class="header" href="#user-story-1">User Story 1</a></h3>
<p>When the tenant team creates or updates workloads that require a large number of Pods, the simultaneous creation of Pods results in the same image being downloaded multiple times. As a result, network throttling may occur. Since network throttling can cause the following issues, the cluster administrators want to avoid triggering it:</p>
<ul>
<li>Other workloads may be unable to download images.</li>
<li>Clients may repeatedly attempt to download images without knowing when to retry, which can lead to intermittent network throttling.</li>
</ul>
<p>The operator can control the source of image retrieval, allowing it to avoid downloading the same image multiple times within the cluster. This reduces the likelihood of network throttling even when a large number of Pods are created simultaneously.</p>
<h3 id="user-story-2"><a class="header" href="#user-story-2">User Story 2</a></h3>
<p>The tenant team wants to pre-download images to minimize downtime during workload creation or updates. By using the operator, the waiting time for image downloads is eliminated during workload creation or updates, minimizing downtime.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<ul>
<li>These features assume that <a href="https://github.com/spegel-org/spegel">spegel</a> is running within the cluster.</li>
<li>Images downloaded by the operator are persisted in the node's local storage.
As a result, any pod scheduled to the node can utilize these images without requiring image pull operations or valid registry credentials.
This behavior may present security concerns in multi-tenant environments where private images are utilized, as it could potentially allow unauthorized access to container images containing confidential information.
If this specification is not acceptable, please consider deploying admission webhooks such as <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages">AlwaysPullImages</a> to enforce proper authentication for all image access operations.</li>
</ul>
<h3 id="risk-and-mitigation"><a class="header" href="#risk-and-mitigation">Risk and Mitigation</a></h3>
<ul>
<li>Security Risk
<ul>
<li>Users might be able to download unauthorized images to nodes within the cluster. This risk can be mitigated by restricting the repositories from which images can be downloaded.</li>
</ul>
</li>
</ul>
<h2 id="the-actual-design"><a class="header" href="#the-actual-design">The actual design</a></h2>
<p>ImagePrefetch Controller</p>
<ul>
<li>The ImagePrefetch controller is a Kubernetes custom controller that handles <code>ImagePrefetch</code> custom resources.</li>
<li>The ImagePrefetch controller monitors the <code>ImagePrefetch</code> custom resource and creates the <code>NodeImageSet</code> custom resource.</li>
</ul>
<p>NodeImageSet controller</p>
<ul>
<li>The NodeImageSet controller operates on each Node and downloads images based on the NodeImageSet custom resource.</li>
<li>The NodeImageSet controller monitors <code>Node</code> resources and, if an image is deleted, it downloads the image again.</li>
</ul>
<h3 id="diagrams"><a class="header" href="#diagrams">Diagrams</a></h3>
<pre><code class="language-mermaid">graph TD;
  prefetch-controller--&gt;|Watch|ImagePrefetch
  User--&gt;|Create|ImagePrefetch
  prefetch-controller--&gt;|Create/Update|NodeImageSet

subgraph kubernetes resources
  ImagePrefetch
  Node
  NodeImageSet
end

subgraph Node1
  NodeImageSet[NodeImageSet]
  containerd
  NodeImageSet-Controller
end

controller--&gt;|get|NodeImageSet
image-puller--&gt;|API call|containerd
controller--&gt;|request to download image|image-puller
controller[NodeImageSet controller]--&gt;|watch|Node

subgraph NodeImageSet-Controller
  controller[NodeImageSet controller]
  image-puller
end
</code></pre>
<pre><code class="language-mermaid">graph TD;


subgraph Node1 
  subgraph image-puller1[Image Puller]
    RegistryPolicyDefault[Registry Policy: Default]
  end
  containerd-node1[Containerd]
  spegel-pod1[Spegel Pod]
end

subgraph upstream
  container-registry[Container Registry]
end

subgraph Node2
  subgraph image-puller2[Image Puller]
    RegistryPolicyMirror[Registry Policy: Mirror]
  end
  containerd-node2[Containerd]
  spegel-pod2[Spegel Pod]
end

subgraph Node3
  subgraph image-puller3[Image Puller]
    RegistryPolicyMirror2[Registry Policy: Mirror]
  end
  containerd-node3[Containerd]
  spegel-pod3[Spegel Pod]
end



%% Node1
image-puller1--&gt;|A1: Request to download container images from the registry mirror and upstream registry|containerd-node1
containerd-node1--&gt;|A2: Attempt to download images from the registry mirror|spegel-pod1
containerd-node1--&gt;|A3: Attempt to download images from the upstream registry|container-registry

%% Node2
image-puller2--&gt;|B1: Request to download container images from the registry mirror|containerd-node2
containerd-node2--&gt;|B2: download images from the registry mirror|spegel-pod2
spegel-pod1&lt;--&gt;|p2p|spegel-pod2

%% Node3
image-puller3--&gt;|C1: Request to download container images from the registry mirror|containerd-node3
containerd-node3--&gt;|C2: download images from the registry mirror|spegel-pod3
spegel-pod1&lt;--&gt;|p2p|spegel-pod3
spegel-pod2&lt;--&gt;|p2p|spegel-pod3
</code></pre>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<p>ImagePrefetch Resource</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td>images</td><td>[]string</td><td>true</td><td>List of images to pre-download</td></tr>
<tr><td>nodeSelector</td><td>metav1.LabelSelector</td><td>false</td><td>Specify the nodes to which the image should be downloaded</td></tr>
<tr><td>allNodes</td><td>bool</td><td>false</td><td>If true, the image will be downloaded to all nodes</td></tr>
<tr><td>replicas</td><td>int</td><td>false</td><td>Set the number of image download nodes</td></tr>
<tr><td>imagePullSecrets</td><td>[]corev1.LocalObjectReference</td><td>false</td><td>Secret used for authentication with the container registry</td></tr>
</tbody></table>
</div>
<pre><code>kind: ImagePrefetch
metadata:
  name: sample
spec:
  images: 
    - ghcr.io/cybozu/ubuntu:24.04
  replicas: 2
  imagePullSecrets:
    - name: regcred
</code></pre>
<p>NodeImageSet Resource</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td>images</td><td>[]string</td><td>true</td><td>Copy of the images specified in ImagePrefetch's <code>.spec.Images</code></td></tr>
<tr><td>registryPolicy</td><td>string</td><td>true</td><td>Registry to use when downloading images</td></tr>
<tr><td>imagePullSecrets</td><td>[]corev1.LocalObjectReference</td><td>false</td><td>Copy of the ImagePrefetch's <code>.spec.imagePullSecrets</code></td></tr>
<tr><td>nodeName</td><td>string</td><td>true</td><td>Node to download images to</td></tr>
</tbody></table>
</div>
<pre><code>kind: NodeImageSet
metadata:
  name: worker1
spec:
  images:
    - ghcr.io/cybozu/ubuntu:24.04
  registryPolicy: Default
  imagePullSecrets:
    - name: regcred
  nodeName: worker1
  imageDownloadRetryLimit: 3
</code></pre>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>This section lists some existing systems and compares their features with those provided by our operator.</p>
<ul>
<li><a href="https://github.com/senthilrch/kube-fledged">kube-fledged</a>
<ul>
<li>kube-fledged provides a custom resource called ImageCache. By creating an ImageCache resource, Job resources are created to download images.</li>
<li>Since kube-fledged uses Job resources to download images, in environments with a large number of nodes, a significant number of Job resources may be created, potentially overloading the kube-apiserver.</li>
<li>Because multiple Job resources are created simultaneously, it is difficult to prevent the same image from being downloaded multiple times within the cluster.</li>
</ul>
</li>
<li><a href="https://openkruise.io/docs/user-manuals/imagepulljob">OpenKruise ImagePullJob</a>
<ul>
<li>OpenKruise provides a custom resource called ImagePullJob. By creating an ImagePullJob resource, you can specify which nodes to pre-download images to. OpenKruise downloads images to the specified nodes via the CRI.</li>
<li>To use the features of ImagePullJob, OpenKruise must be installed.</li>
</ul>
</li>
<li><a href="https://github.com/mattmoor/warm-image">warm-image</a>
<ul>
<li>warm-image provides a custom resource called WarmImage. By creating a WarmImage resource, a DaemonSet is created to download images.</li>
<li>Since warm-image uses a DaemonSet to download images, images are downloaded on all nodes. This means images may be downloaded to nodes where they are not needed.</li>
<li>No resource is provided to indicate whether images have been downloaded, so users must verify that the created DaemonSet is functioning correctly.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-procedure"><a class="header" href="#release-procedure">Release procedure</a></h1>
<p>This document describes how to release a new version.</p>
<h2 id="labeling"><a class="header" href="#labeling">Labeling</a></h2>
<p>Release notes are automatically generated based on PRs included in the release.
Those PRs are categorized based on the label assigned to them.
Please refer to <code>.github/release.yml</code> for the kind of labels.</p>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p>Follow <a href="https://semver.org/spec/v2.0.0.html">semantic versioning 2.0.0</a> to choose the new version number.</p>
<h2 id="bump-version"><a class="header" href="#bump-version">Bump version</a></h2>
<ol>
<li>
<p>Determine a new version number and set the <code>VERSION</code> variable.</p>
<pre><code class="language-console"># Set VERSION and confirm it. It should not have a "v" prefix.
$ VERSION=x.y.z
$ echo $VERSION
</code></pre>
</li>
<li>
<p>Update the chart version and appVersion in <code>charts/ofen/Chart.yaml</code>.</p>
<pre><code class="language-console">$ sed -i -E "s/^version: .+/version: $VERSION/" charts/ofen/Chart.yaml
$ sed -i -E "s/^appVersion: .+/appVersion: \"$VERSION\"/" charts/ofen/Chart.yaml
</code></pre>
</li>
<li>
<p>Create a PR to bump the version and merge it.</p>
<pre><code class="language-console">$ git checkout -b bump-version-to-$VERSION
$ git add charts/ofen/Chart.yaml
$ git commit -m "Bump version to $VERSION"
$ git push
</code></pre>
</li>
<li>
<p>Add a git tag to the main branch HEAD and push it.</p>
<pre><code class="language-console"># Set VERSION again.
$ VERSION=x.y.z
$ echo $VERSION

$ git checkout main
$ git pull
$ git tag -a -m "Release v$VERSION" "v$VERSION"

# Make sure the release tag exists.
$ git tag -ln | grep $VERSION

$ git push origin "v$VERSION"
</code></pre>
</li>
</ol>
<p>GitHub actions will build and push artifacts such as container images and
create a new GitHub release.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
